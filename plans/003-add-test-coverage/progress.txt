## 2026-02-08 — T02: Utility functions tests (done)

Created `src/utils/index.test.ts` with 26 tests covering all exported utility functions:

- **normalizeDomain** (5 tests): port stripping, multi-segment ports, falsy inputs
- **parseError** (4 tests): non-Error returns null, plain Error message, AxiosError with ONIX structure, AxiosError fallback
- **calculatePrice** (9 tests): PER_KWH (basePrice × quantity, wheelingCharges, defaults), FIXED (ignores quantity, adds wheeling), SUBSCRIPTION (basePrice only), TIME_OF_DAY (matching rate, no match falls back to basePrice, undefined rates, empty rates), unknown model (uses PER_KWH formula)
- **calculateTotalAmount** (6 tests): extracts beckn:price, default PER_KWH, wheelingCharges from offerAttributes, TIME_OF_DAY with rates, FIXED pricing, missing offerAttributes

All 26 tests pass. Full suite: 452 tests, 24 suites, all green.

Notes for next person:
- TIME_OF_DAY tests use `jest.useFakeTimers()` + `jest.setSystemTime()` to control `new Date().getUTCHours()`. Remember to call `jest.useRealTimers()` in afterEach.
- AxiosError constructor needs `AxiosHeaders` import for the config.headers param.
- These are pure functions with zero mocks (no DB, no external calls) — the simplest test pattern in the codebase.

## 2026-02-08 — T01: Auth routes tests (done)

Created `src/auth/routes.test.ts` with 35 tests covering all auth endpoints, middleware, and JWT utilities:

- **signToken/verifyToken** (2 tests): round-trip JWT encode/decode, expired and tampered token rejection
- **authMiddleware** (4 tests): missing header → 401, non-Bearer header → 401, invalid JWT → TOKEN_MALFORMED, valid token → sets req.user + calls next()
- **validateBody** (2 tests): Zod schema pass-through, VALIDATION_ERROR on failure
- **POST /api/auth/login** (8 tests): valid login returns token + user, wrong PIN → 401, non-existent phone → 401, missing phone → 400, invalid phone format → 400, short PIN → 400, non-numeric PIN → 400, userId included in JWT
- **POST /api/auth/verify-vc** (14 tests): 401 without token, empty credentials → 400, invalid did format → 400, missing VerifiableCredential type → 400, user not found → 404, successful verification stores profile + sets vcVerified, issuerName→utilityId mapping, meterNumber extraction, non-ISSUED status → failed, check failures → failed, timeout → 503, 5xx → 503, 404 → failed entry, multiple credentials in one request
- **GET /api/auth/me** (5 tests): 401 without token, 404 unknown userId, role=prosumer when generationProfile exists, role=consumer otherwise, all profile fields + meters + memberSince

All 35 tests pass. Full suite: 487 tests, 25 suites, all green.

Notes for next person:
- Uses **in-memory MongoDB** (setupTestDB pattern) — NOT a simple DB mock. Real DB operations for auth tests give higher confidence.
- Uses **real JWT** (no jsonwebtoken mock). `signToken`/`verifyToken` are exported from routes.ts and used directly.
- **axios is mocked** (`jest.mock('axios')`) for the external VC verification API calls. Mock responses need `data: { status, checks }` structure.
- For verify-vc tests, create token via `signToken(phone, user._id.toString())` after seeding user and fetching with `getTestUser()`.
- `seedUser` and `seedUserWithProfiles` from test-utils/db are the main seeding helpers. `seedUserWithProfiles` accepts optional vcVerified, profiles, and meters.
- The `restoreMocks: true` in jest.config resets mock implementations between tests, so each test must set its own `mockAxios.get.mockResolvedValue(...)`.
- Error mocks for axios: use plain Error with extra properties (`.code`, `.response.status`) rather than AxiosError constructor — the handler checks these properties directly.

## 2026-02-08 — T03: Payment service tests (done)

Created `src/services/payment-service.test.ts` with 15 tests covering all 4 exported methods:

- **createOrder** (4 tests): amount→paise conversion (×100), Math.floor for fractional amounts, currency/receipt/notes passthrough, error propagation
- **createPaymentLink** (4 tests): correct params with accept_partial=false and callback_url, AxiosError returns response.data instead of throwing, non-Axios errors propagate
- **verifyPayment** (5 tests): valid signature updates DB (status, paymentId, razorpaySignature), maps known status strings to PaymentStatus enum, unknown status → FAILED, invalid signature returns false, missing RAZORPAY_KEY_SECRET throws
- **getPayment** (2 tests): retrieves by orderId, returns null for missing orderId

All 15 tests pass. Full suite: 502 tests, 26 suites, all green.

Notes for next person:
- Uses **in-memory MongoDB** (setupTestDB pattern) for verifyPayment and getPayment tests that hit the `payments` collection.
- `razorpay` module is fully mocked — `razorpay.orders.create` and `razorpay.paymentLink.create` are jest.fn() wrappers. `rzp_key_secret` is set to `'test-secret-key'`.
- `validatePaymentVerification` from `razorpay/dist/utils/razorpay-utils` is also mocked — returns true/false to control signature validation flow.
- For the AxiosError test, use `jest.requireActual('axios')` to get the real `AxiosError` constructor so `instanceof AxiosError` check works in the source code.
- To test missing `rzp_key_secret`, require the mocked module and temporarily set it to empty string, then restore after assertion.
- `restoreMocks: true` in jest.config resets mock implementations between tests, so each test must re-configure its mock return values.

## 2026-02-08 — T04: BAP webhook controller tests (done)

Created `src/bap-webhook/controller.test.ts` with 30 tests covering all 9 exported handlers:

- **onSelect** (6 tests): ACK response, resolve pending txn, no pending txn handling, error in body still ACKs, error passed through to resolved data, missing context graceful handling
- **onInit** (3 tests): ACK response, resolve pending txn, error field pass-through
- **onConfirm** (13 tests): ACK response, resolve pending txn, BUYER settlement creation with correct quantity, multi-item quantity sum, sellerPlatformId from context.bpp_id, sellerDiscomId from orderAttributes.utilityIdSeller, saveBuyerOrder call, sendOrderConfirmation call, no settlement when error present, no settlement when order missing, graceful handling of settlement creation failure, fallback orderItemId chains (beckn:orderedItem → beckn:id → item-{txnId}), empty orderItems (qty=0)
- **onStatus** (2 tests): ACK response, resolve pending txn
- **onCancel** (1 test): ACK + resolve pending txn
- **onUpdate** (1 test): ACK + resolve pending txn
- **onRating** (1 test): ACK + resolve pending txn
- **onSupport** (1 test): ACK + resolve pending txn
- **onTrack** (1 test): ACK + resolve pending txn

All 30 tests pass. Full suite: 532 tests, 27 suites, all green.

Notes for next person:
- **Transaction store is NOT mocked** — uses real in-memory `createPendingTransaction`/`resolvePendingTransaction`/`hasPendingTransaction` since transaction-store is a pure in-memory Map.
- **settlementStore, orderService, notificationService are mocked** via `jest.mock()` since they hit MongoDB.
- Uses `mockRequest`/`mockResponse` from `test-utils/index.ts` for handler invocation (not supertest since these are raw handlers, not routes).
- `flushPromises()` + `setTimeout(50ms)` is needed for `onConfirm` tests because settlement/order/notification logic runs in a detached async IIFE `(async () => { ... })()`.
- `restoreMocks: true` in jest.config clears mock implementations between tests. For `onConfirm` tests that check mocks were NOT called, explicitly call `mockClear()` at start of that test.
- Each test uses unique transaction IDs to prevent cross-test interference in the shared in-memory transaction store.
