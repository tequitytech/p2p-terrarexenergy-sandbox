## 2026-02-08 — T02: Utility functions tests (done)

Created `src/utils/index.test.ts` with 26 tests covering all exported utility functions:

- **normalizeDomain** (5 tests): port stripping, multi-segment ports, falsy inputs
- **parseError** (4 tests): non-Error returns null, plain Error message, AxiosError with ONIX structure, AxiosError fallback
- **calculatePrice** (9 tests): PER_KWH (basePrice × quantity, wheelingCharges, defaults), FIXED (ignores quantity, adds wheeling), SUBSCRIPTION (basePrice only), TIME_OF_DAY (matching rate, no match falls back to basePrice, undefined rates, empty rates), unknown model (uses PER_KWH formula)
- **calculateTotalAmount** (6 tests): extracts beckn:price, default PER_KWH, wheelingCharges from offerAttributes, TIME_OF_DAY with rates, FIXED pricing, missing offerAttributes

All 26 tests pass. Full suite: 452 tests, 24 suites, all green.

Notes for next person:
- TIME_OF_DAY tests use `jest.useFakeTimers()` + `jest.setSystemTime()` to control `new Date().getUTCHours()`. Remember to call `jest.useRealTimers()` in afterEach.
- AxiosError constructor needs `AxiosHeaders` import for the config.headers param.
- These are pure functions with zero mocks (no DB, no external calls) — the simplest test pattern in the codebase.

## 2026-02-08 — T01: Auth routes tests (done)

Created `src/auth/routes.test.ts` with 35 tests covering all auth endpoints, middleware, and JWT utilities:

- **signToken/verifyToken** (2 tests): round-trip JWT encode/decode, expired and tampered token rejection
- **authMiddleware** (4 tests): missing header → 401, non-Bearer header → 401, invalid JWT → TOKEN_MALFORMED, valid token → sets req.user + calls next()
- **validateBody** (2 tests): Zod schema pass-through, VALIDATION_ERROR on failure
- **POST /api/auth/login** (8 tests): valid login returns token + user, wrong PIN → 401, non-existent phone → 401, missing phone → 400, invalid phone format → 400, short PIN → 400, non-numeric PIN → 400, userId included in JWT
- **POST /api/auth/verify-vc** (14 tests): 401 without token, empty credentials → 400, invalid did format → 400, missing VerifiableCredential type → 400, user not found → 404, successful verification stores profile + sets vcVerified, issuerName→utilityId mapping, meterNumber extraction, non-ISSUED status → failed, check failures → failed, timeout → 503, 5xx → 503, 404 → failed entry, multiple credentials in one request
- **GET /api/auth/me** (5 tests): 401 without token, 404 unknown userId, role=prosumer when generationProfile exists, role=consumer otherwise, all profile fields + meters + memberSince

All 35 tests pass. Full suite: 487 tests, 25 suites, all green.

Notes for next person:
- Uses **in-memory MongoDB** (setupTestDB pattern) — NOT a simple DB mock. Real DB operations for auth tests give higher confidence.
- Uses **real JWT** (no jsonwebtoken mock). `signToken`/`verifyToken` are exported from routes.ts and used directly.
- **axios is mocked** (`jest.mock('axios')`) for the external VC verification API calls. Mock responses need `data: { status, checks }` structure.
- For verify-vc tests, create token via `signToken(phone, user._id.toString())` after seeding user and fetching with `getTestUser()`.
- `seedUser` and `seedUserWithProfiles` from test-utils/db are the main seeding helpers. `seedUserWithProfiles` accepts optional vcVerified, profiles, and meters.
- The `restoreMocks: true` in jest.config resets mock implementations between tests, so each test must set its own `mockAxios.get.mockResolvedValue(...)`.
- Error mocks for axios: use plain Error with extra properties (`.code`, `.response.status`) rather than AxiosError constructor — the handler checks these properties directly.

## 2026-02-08 — T03: Payment service tests (done)

Created `src/services/payment-service.test.ts` with 15 tests covering all 4 exported methods:

- **createOrder** (4 tests): amount→paise conversion (×100), Math.floor for fractional amounts, currency/receipt/notes passthrough, error propagation
- **createPaymentLink** (4 tests): correct params with accept_partial=false and callback_url, AxiosError returns response.data instead of throwing, non-Axios errors propagate
- **verifyPayment** (5 tests): valid signature updates DB (status, paymentId, razorpaySignature), maps known status strings to PaymentStatus enum, unknown status → FAILED, invalid signature returns false, missing RAZORPAY_KEY_SECRET throws
- **getPayment** (2 tests): retrieves by orderId, returns null for missing orderId

All 15 tests pass. Full suite: 502 tests, 26 suites, all green.

Notes for next person:
- Uses **in-memory MongoDB** (setupTestDB pattern) for verifyPayment and getPayment tests that hit the `payments` collection.
- `razorpay` module is fully mocked — `razorpay.orders.create` and `razorpay.paymentLink.create` are jest.fn() wrappers. `rzp_key_secret` is set to `'test-secret-key'`.
- `validatePaymentVerification` from `razorpay/dist/utils/razorpay-utils` is also mocked — returns true/false to control signature validation flow.
- For the AxiosError test, use `jest.requireActual('axios')` to get the real `AxiosError` constructor so `instanceof AxiosError` check works in the source code.
- To test missing `rzp_key_secret`, require the mocked module and temporarily set it to empty string, then restore after assertion.
- `restoreMocks: true` in jest.config resets mock implementations between tests, so each test must re-configure its mock return values.

## 2026-02-08 — T07: Settlement poller tests (done)

Created `src/services/settlement-poller.test.ts` with 25 tests covering all 6 exported functions:

- **pollOnce** (13 tests): empty pending list, ledger query per settlement, settlement update on ledger record, counter increment, newlySettled tracking, markOnSettleNotified after callback, skip callback when already notified, buyer order → DELIVERED, seller order → DELIVERED, error isolation per settlement, isPolling finally-block reset, no order update when not SETTLED, graceful order update failure
- **triggerOnSettle** (5 tests): POST to callback URL with correct payload, context with action=on_settle and settlement details, skip when no URL configured, catch callback errors without throwing, use saved order domain
- **refreshSettlement** (4 tests): query ledger + update store, trigger callback for newly settled, return null when no ledger record, skip callback when already notified
- **startPolling** (1 test): disabled when ENABLE_SETTLEMENT_POLLING=false
- **stopPolling** (1 test): safe to call when not running
- **getPollingStatus** (1 test): returns current state object

All 25 tests pass. Full suite: 557 tests, 28 suites, all green.

Notes for next person:
- **Uses in-memory MongoDB** (setupTestDB pattern) with real `settlementStore` for DB operations. Only `ledgerClient`, `orderService`, `catalogStore`, and `axios` are mocked.
- **Module loaded with dynamic import** (`await import('./settlement-poller')`) because it reads `process.env.ENABLE_SETTLEMENT_POLLING` at module level. Set env vars before import.
- `process.env.ENABLE_SETTLEMENT_POLLING = 'false'` prevents the poller from auto-starting during tests.
- `process.env.ON_SETTLE_CALLBACK_URL` is toggled per test — set to a URL to test callback logic, empty string to test skip-callback path.
- `uuid.v4` is mocked to `'test-uuid-1234'` for deterministic `message_id` assertions in callback payload.
- For `onSettleNotified` tests, insert settlement documents directly into DB with `onSettleNotified: true` rather than using `seedSettlement` (which defaults to false).
- The `isPolling` guard test is implicit — tested via the "reset isPolling flag even on error" test which verifies a second poll runs after a failed first one.
- `restoreMocks: true` in jest.config clears mock implementations between tests — re-configure mocks in each test.

## 2026-02-08 — T04: BAP webhook controller tests (done)

Created `src/bap-webhook/controller.test.ts` with 30 tests covering all 9 exported handlers:

- **onSelect** (6 tests): ACK response, resolve pending txn, no pending txn handling, error in body still ACKs, error passed through to resolved data, missing context graceful handling
- **onInit** (3 tests): ACK response, resolve pending txn, error field pass-through
- **onConfirm** (13 tests): ACK response, resolve pending txn, BUYER settlement creation with correct quantity, multi-item quantity sum, sellerPlatformId from context.bpp_id, sellerDiscomId from orderAttributes.utilityIdSeller, saveBuyerOrder call, sendOrderConfirmation call, no settlement when error present, no settlement when order missing, graceful handling of settlement creation failure, fallback orderItemId chains (beckn:orderedItem → beckn:id → item-{txnId}), empty orderItems (qty=0)
- **onStatus** (2 tests): ACK response, resolve pending txn
- **onCancel** (1 test): ACK + resolve pending txn
- **onUpdate** (1 test): ACK + resolve pending txn
- **onRating** (1 test): ACK + resolve pending txn
- **onSupport** (1 test): ACK + resolve pending txn
- **onTrack** (1 test): ACK + resolve pending txn

All 30 tests pass. Full suite: 532 tests, 27 suites, all green.

Notes for next person:
- **Transaction store is NOT mocked** — uses real in-memory `createPendingTransaction`/`resolvePendingTransaction`/`hasPendingTransaction` since transaction-store is a pure in-memory Map.
- **settlementStore, orderService, notificationService are mocked** via `jest.mock()` since they hit MongoDB.
- Uses `mockRequest`/`mockResponse` from `test-utils/index.ts` for handler invocation (not supertest since these are raw handlers, not routes).
- `flushPromises()` + `setTimeout(50ms)` is needed for `onConfirm` tests because settlement/order/notification logic runs in a detached async IIFE `(async () => { ... })()`.
- `restoreMocks: true` in jest.config clears mock implementations between tests. For `onConfirm` tests that check mocks were NOT called, explicitly call `mockClear()` at start of that test.
- Each test uses unique transaction IDs to prevent cross-test interference in the shared in-memory transaction store.

## 2026-02-08 — T05: Expand order-service tests (done)

Expanded `src/services/order-service.test.ts` from 3 to 17 tests, covering all 6 methods in order-service.ts:

- **saveBuyerOrder** (3 tests): save + retrieve, upsert when same transactionId exists, default status to INITIATED when not provided
- **getBuyerOrder** (2 tests): single order by transactionId, returns null when not found
- **updateBuyerOrderStatus** (3 tests): status update with extra fields, warn when no match (matchedCount=0), merge additional update fields (razorpayPaymentId, razorpaySignature, paymentId)
- **getSellerOrders** (3 tests): returns from 'orders' collection with type=SELLER, empty array when none exist, sort by createdAt descending
- **updateSellerOrderStatus** (3 tests): updates both orderStatus and status fields, warns when no match, merges additional fields (settlementId, actualDelivered)
- **getCombinedOrders** (3 tests): combines buyer + seller orders, sorts by createdAt descending across both collections, returns empty array when no orders

All 17 tests pass. Full suite passes.

Notes for next person:
- Uses **in-memory MongoDB** (setupTestDB pattern) — same as the original 3 tests.
- Seller orders go in the `orders` collection (not `buyer_orders`). Use `getTestDB().collection('orders').insertOne()` to seed seller orders.
- `console.warn` spy tests need `mockRestore()` to clean up — use `jest.spyOn(console, 'warn').mockImplementation()` and restore after assertion.
- The upsert test verifies that calling `saveBuyerOrder` twice with the same transactionId results in only 1 document (second call updates rather than inserts).
- Combined orders sort test uses 3 orders across 2 collections (1 buyer at middle date, 2 sellers at oldest/newest) to verify cross-collection descending sort.

## 2026-02-08 — T06: Expand catalog-store tests (done)

Expanded `src/services/catalog-store.test.ts` from 29 to 59 tests, covering all remaining methods in catalog-store.ts:

- **getSellerEarnings** (6 tests): total from confirmed/scheduled orders, 0 for no orders, date range filtering via from/to, 2 decimal place rounding, excluding non-confirmed/scheduled statuses, multi-item sum within single order
- **getSellerTotalSold** (4 tests): sum unitQuantity from confirmed/scheduled, 0 for no orders, multi-item sum, excludes cancelled orders
- **getSellerAvailableInventory** (3 tests): sum availableQuantity from items, 0 when no items, excludes other sellers' items
- **getBeneficiaryDonations** (3 tests): donations only from verified beneficiaries (vcVerified+isVerifiedBeneficiary), 0 for no donations, sum across multiple orders (CONFIRMED, COMPLETED, SCHEDULED)
- **getSellerUserIdForItem** (5 tests): direct item.userId, catalog.userId fallback, meterId→user lookup fallback, null for not found, null when all fallbacks fail
- **getPublishedItems** (5 tests): active items with matching offers qty>0, excludes items with no offers, excludes zero-qty offers, $lookup joins items↔offers by beckn:id, excludes inactive items
- **reduceOfferInventory** (4 tests): decrement unitQuantity, throw on insufficient inventory, reduce to zero, throw for non-existent offer

All 59 tests pass. Full suite: 601 tests, 28 suites, all green.

Notes for next person:
- Uses **in-memory MongoDB** (setupTestDB pattern) — same as the existing tests.
- For `getSellerEarnings`/`getSellerTotalSold` tests, seed orders directly via `getTestDB().collection('orders').insertOne()` with the full nested beckn order structure (`order.beckn:seller`, `order.beckn:orderStatus`, `order.beckn:orderItems`).
- The aggregation pipeline tests require exact field path matching: `order.beckn:orderItems.beckn:quantity.unitQuantity` for quantities, `order.beckn:orderItems.beckn:acceptedOffer.beckn:offerAttributes.beckn:price.value` for prices.
- For `getBeneficiaryDonations`, seed users with `vcVerified: true` AND `isVerifiedBeneficiary: true` plus `profiles.consumptionProfile.id` — the function builds a Set from these IDs to filter orders by `beckn:buyer.beckn:id`.
- `reduceOfferInventory` uses `beckn:price.applicableQuantity.unitQuantity` path (different from old `reduceInventory` which uses `beckn:itemAttributes.availableQuantity` on items).
- `getPublishedItems` uses MongoDB `$lookup` with `$expr` — the test verifies offers are joined by checking `beckn:items` array contains the item's `beckn:id`.

## 2026-02-08 — T08: Notification service tests (done)

Created `src/services/notification-service.test.ts` with 10 tests covering the `sendOrderConfirmation` method:

- **sendOrderConfirmation** (10 tests): send email to buyer with verified email, include transactionId/totalQuantity/seller/amount in email body, find user by consumptionProfile.id, find user by utilityCustomer.did as fallback, find user by phone as last fallback, skip when no buyer ID in order, skip when user not found in DB, skip when user has no email, calculate totalQuantity from multiple orderItems, catch and log emailService errors without throwing

All 10 tests pass. Full suite: 611 tests, 29 suites, all green.

Notes for next person:
- Uses **in-memory MongoDB** (setupTestDB pattern) for user lookups. The `seedUserWithProfiles` helper from test-utils/db does NOT have an `email` field, so users are inserted directly via `getTestDB().collection('users').insertOne()`.
- **emailService is mocked** (`jest.mock('./email-service')`) — `sendEmail` is a jest.fn() that returns `true` by default. Reset with `mockResolvedValue(true)` in `beforeEach`.
- The $or query fallback chain (consumptionProfile.id → utilityCustomer.did → phone) is tested by seeding users with only one matching field each.
- For the "no email" test, insert user with `email: null` — the source checks `!user.email` which covers both null and undefined.
- For the error handling test, `mockSendEmail.mockRejectedValue(new Error(...))` triggers the catch block. The test verifies the function resolves without throwing (try/catch in source swallows the error).
- `restoreMocks: true` in jest.config resets mock implementations between tests, so `mockSendEmail.mockResolvedValue(true)` is set in beforeEach.

## 2026-02-08 — T10: Expand sync-api controller tests (done)

Expanded `src/sync-api/controller.test.ts` from 24 to 50 tests (+26), covering all simplified API formats and validation middleware:

- **isAckResponse** (7 tests, +2 new): ACK/NACK detection in JSON and string formats, NACK priority in malformed, null/unknown format, ACK with spaces around colon
- **syncSelect — raw beckn** (8 tests, +2 new): forward to ONIX, transaction ID, business error, timeout, 500, BUSINESS_ERROR code verification, 502 UPSTREAM_ERROR from ONIX
- **syncSelect — catalog-based format** (6 tests, all new): transform catalog to beckn order with buyer details, 401 when no userId, 403 NO_BUYER_PROFILE, 400 invalid schema (empty items), selectedOfferId selection, 500 on non-profile extractBuyerDetails error
- **syncInit — raw beckn** (2 tests, existing): forward and success response
- **syncInit — select-based format** (5 tests, all new): transform to init with fulfillment + payment + settlement accounts, wheeling charges calculation (10 kWh × 5.5 + 10 × 1.50 = 70), 401 no userId, 400 invalid schema (empty payment.id), 400 empty orderItems
- **syncConfirm — raw beckn** (5 tests, existing): buyer/seller utilityId validation, empty string, forward, business error
- **syncConfirm — init-based format** (4 tests, all new): transform to confirm with AUTHORIZED payment status, missing buyer utilityId, missing seller utilityId, empty buyer utilityId
- **syncStatus** (2 tests, existing)
- **syncHealth** (2 tests, +1 new): health status, pending count from transaction store
- **validateSelect middleware** (2 tests, all new): catalog-based passthrough, standard format validation
- **validateInit middleware** (3 tests, all new): select-based passthrough, reject missing transaction_id, pass valid transaction_id
- **validateConfirm middleware** (3 tests, all new): init-based passthrough, reject missing transaction_id, pass valid transaction_id
- **error handling** (2 tests, existing)

All 50 tests pass. Full suite: 647 tests, 29 suites, all green.

Notes for next person:
- **`extractBuyerDetails` is mocked** via `jest.mock('../trade/routes')` using `jest.requireActual` to preserve other exports. This is cleaner than mocking `../db` since only the catalog-based path needs DB access.
- Three helper factories (`createCatalogBasedSelectBody`, `createSelectBasedInitBody`, `createInitBasedConfirmBody`) build valid request bodies with override support for targeted test variations.
- For the wheeling charges test: WHEELING_RATE defaults to 1.50 INR/kWh. Total = (price × qty) + (qty × WHEELING_RATE) = (5.5 × 10) + (10 × 1.50) = 70 INR.
- The init-based confirm transform sets `beckn:paymentStatus` to `'AUTHORIZED'` (from `'INITIATED'`).
- `validateSelect`, `validateInit`, `validateConfirm` are exported middleware functions tested with `mockNext()`.
- `mockedAxios.post.mock.calls[0][1]` extracts the posted body — cast to `any` to avoid TS errors.
- `restoreMocks: true` in jest.config resets mock implementations between tests.

## 2026-02-08 — T09: Expand webhook controller tests (done)

Expanded `src/webhook/controller.test.ts` from 42 to 49 tests (+7), adding in-memory MongoDB tests for `onSelect` and `onConfirm` business logic:

- **onSelect — inventory check** (3 tests): ACK immediate response, INSUFFICIENT_INVENTORY error callback when requested > available qty, successful on_select with CREATED status when qty is sufficient
- **onConfirm — settlement + inventory + republish** (4 tests): ACK immediate response, settlement record creation with totalQuantity sum from multiple orderItems, INSUFFICIENT_INVENTORY error callback when pre-check fails (no settlement created), inventory reduction on offer + catalog republish to ONIX + seller order saved with SCHEDULED status

All 49 tests pass. Full suite: 619 tests, 29 suites, all green.

Notes for next person:
- **Uses in-memory MongoDB** (setupTestDB pattern) — DB is required because `onSelect` and `onConfirm` use real `catalogStore` (getItem, getOffer, reduceOfferInventory, buildCatalogForPublish, saveOrder) and `settlementStore.createSettlement`.
- **DB mock approach differs from existing tests**: the original tests only mocked `readDomainResponse` for template handlers (onUpdate, onRating, etc.). The new tests mock `../db` module to point at `getTestDB()`, enabling real MongoDB operations for onSelect/onConfirm.
- **`parseError` must NOT be mocked** — it's used by onConfirm's catch block. The utils mock now uses `jest.requireActual('../utils')` to keep parseError working while mocking readDomainResponse.
- **payment-service is mocked** since onInit (called internally) creates Razorpay orders. Mock returns dummy `{ id, amount, currency }` and `{ short_url }`.
- Offers must have `beckn:price.applicableQuantity.unitQuantity` field for both onSelect availability check and onConfirm pre-check + `reduceOfferInventory`.
- Async handler tests need `setTimeout(200-500ms)` because onSelect/onConfirm run their business logic in detached `(async () => { ... })()` IIFEs that fire-and-forget.
- Each test uses unique item/offer/transaction IDs and `clearTestDB()` in beforeEach to prevent cross-test interference.
- The republish test verifies both the `/bpp/caller/publish` POST and the `on_confirm` callback POST by searching `mockedAxios.post.mock.calls` for matching URLs.
