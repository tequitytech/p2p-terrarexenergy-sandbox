# Cross-Platform Energy Gifting — Technical Specification

**Version:** 1.0
**Date:** February 2026
**Status:** Draft

## Goal

Allow prosumers to gift energy to recipients on any Beckn-compliant app within the same DISCOM network, using a privacy-preserving two-hash model for discovery and claim verification.

## References

- [EnergyGift schema (v0.3)](https://github.com/beckn/protocol-specifications-v2/blob/p2p-trading/schema/EnergyTrade/v0.3/attributes.yaml#L82)
- @gifting_slide.md — one-pager flow
- @gifting_solution_note.md — design rationale

---

## 1. Scope

| In scope | Out of scope |
|----------|-------------|
| BPP sandbox (gift creation, claim validation, lifecycle) | BAP sandbox changes (BAP app concern) |
| Cross-app, same DISCOM | Inter-discom gifting |
| Prosumer-to-anyone gifting | Consumer re-gifting |
| Unit/integration tests | Postman collection |
| Extend existing `/api/publish` endpoint | New standalone gift module |

**Coexistence:** The existing `energy-request` module (`/api/gift`, `/api/donate`) remains unchanged. It handles "buy on behalf of beneficiary from market." This new feature handles "seller publishes a targeted gift offer with claim code."

---

## 2. Core Mechanism — Two-Hash Model

Two SHA-256 hashes enable private discovery and trustless claim verification:

### lookupHash (Discovery)

```
lookupHash = SHA256(recipientPhone)
```

- **Input:** 10-digit Indian mobile (e.g., `9876543210`). `+91` prepended internally before hashing.
- **No salt.** SHA256 of E.164 phone alone is sufficient; phone numbers have enough entropy.
- Published to CDS as part of `offerAttributes.gift`
- Recipient's BAP computes the same hash (`SHA256('+91' + phone)`) and queries CDS via JSONPath filter

### claimVerifier (Validation)

```
claimVerifier = SHA256(claimSecret)
```

- **claimSecret:** 8-character alphanumeric, generated by BPP at publish time
- ~2.8 trillion combinations; no rate limiting required
- claimVerifier is published to CDS; claimSecret is sent to recipient via SMS
- BPP validates by hashing the presented secret and comparing to stored claimVerifier

---

## 3. Gift Lifecycle

```
┌─────────────────────────────────────────────────────────────────┐
│  GIFTER (Prosumer)                                              │
│  POST /api/publish { ..., recipientPhone, isGift: true }        │
│  → BPP generates claimSecret, computes hashes                   │
│  → Stores offer with gift fields in offers collection            │
│  → Publishes to CDS (price=0, with gift attributes)             │
│  → Sends SMS to recipient with claimSecret                      │
│  → Gift appears in gifter's "Published Items" (tagged as gift)  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  RECIPIENT (any app, same DISCOM)                               │
│  Explicit "Check for gifts" action                              │
│  → BAP computes lookupHash = SHA256(user's E.164 phone)         │
│  → Sends Beckn discover with lookupHash in JSONPath filter      │
│  → Gift offers appear (visible but locked — need secret)        │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  CLAIM FLOW (standard Beckn with claimSecret in payload)        │
│                                                                  │
│  select  → claimSecret in message → BPP validates at on_select  │
│  init    → claimSecret in message → BPP re-validates at on_init │
│  confirm → claimSecret in message → BPP re-validates, finalizes │
│                                                                  │
│  Failed validation → Beckn NACK: GIFT_CLAIM_FAILED              │
│  Full flow with explicit consent (recipient reviews & confirms)  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  POST-CLAIM                                                      │
│  → Offer status updated to CLAIMED in DB                        │
│  → Offer stays in CDS with status=CLAIMED                       │
│  → Standard order created (like any trade)                      │
│  → Gifter notified via SMS/email that gift was claimed          │
│  → Energy scheduled to recipient's meter                        │
└─────────────────────────────────────────────────────────────────┘
```

### Status Transitions

```
UNCLAIMED → CLAIMED     (recipient successfully confirms)
UNCLAIMED → REVOKED     (gifter cancels before claim)
UNCLAIMED → EXPIRED     (expiresAt passed, detected passively)
```

---

## 4. API Changes

### 4.1 Extend `POST /api/publish` (Gift Creation)

**Additional input fields** (all optional; if `isGift: true`, `recipientPhone` is required):

```typescript
{
  // ... existing fields (quantity, price, deliveryDate, startHour, duration, sourceType)
  isGift?: boolean;           // true = gift offer
  recipientPhone?: string;    // 10-digit Indian mobile number, e.g. "9876543210"
}
```

**Validation:** `recipientPhone` must be exactly 10 digits, starting with 6-9. Reject anything else (no +91 prefix, no country code, no spaces/dashes). The `+91` prefix is added internally before hashing.

**Server-side behavior when `isGift: true`:**

1. Validate gifter has generation profile (prosumer only)
2. Validate `recipientPhone` is exactly 10 digits starting with 6-9
3. Generate 8-char alphanumeric `claimSecret`
4. Compute `lookupHash = SHA256('+91' + recipientPhone)`
5. Compute `claimVerifier = SHA256(claimSecret)`
6. Set `price = 0` (publish Zod schema currently has `z.number().positive()` — relax to `.nonnegative()` when `isGift: true`)
7. Set `expiresAt = now + 7 days`
8. Build offer with `beckn:offerAttributes.gift` sub-attribute
9. Store in offers collection (extended fields)
10. Publish to CDS via ONIX
11. Log gift details: `console.log('[GIFT] Created gift for ${recipientPhone}, claimSecret: ${claimSecret}, lookupHash: ${lookupHash}')`
12. Return standard publish response (no extra gift fields — claimSecret retrievable from published items listing)

### 4.2 Extend `PATCH /api/publish/:offerId` (Revoke)

**New action — soft revoke:**

```typescript
PATCH /api/publish/:offerId
{ status: "REVOKED" }
```

- Only allowed if offer `isGift: true` and current status is `UNCLAIMED`
- Sets `giftStatus = REVOKED` in DB
- Does NOT remove from CDS — BPP rejects subsequent claim attempts with NACK
- Returns `{ success: true, status: "REVOKED" }`

### 4.3 Extend `GET /api/publish/:offerId` or published items listing

- Gift offers appear in existing published items list, tagged with:
  - `isGift: true`
  - `giftStatus: UNCLAIMED | CLAIMED | REVOKED | EXPIRED`
  - `claimSecret` (gifter can view and resend)
  - `recipientPhone` (masked, e.g., `+91****3210`)
- "Resend SMS" action: `POST /api/publish/:offerId/resend-sms`

---

## 5. Beckn Protocol Integration

### 5.1 Offer Schema Extension (EnergyGift)

The `EnergyTradeOffer` schema has an optional `gift` property (type `EnergyGift`):

```json
{
  "beckn:offerAttributes": {
    "@type": "EnergyTradeOffer",
    "pricingModel": "PER_KWH",
    "deliveryWindow": { ... },
    "validityWindow": { ... },
    "gift": {
      "@type": "EnergyGift",
      "lookupHash": "a1b2c3...sha256hex",
      "claimVerifier": "d4e5f6...sha256hex",
      "expiresAt": "2026-02-17T00:00:00Z"
    }
  }
}
```

> **Note:** The property name is `gift` (not `energyGift`), matching the [EnergyTradeOffer schema](https://github.com/beckn/protocol-specifications-v2/blob/p2p-trading/schema/EnergyTrade/v0.3/attributes.yaml#L82). `status` is tracked in the local DB only, not in the published offer attributes.

### 5.2 Discovery (JSONPath Filter)

Discovery uses a JSONPath filter expression inside `message.filters`, matching the existing `buildDiscoverRequest` pattern in `src/bidding/services/market-analyzer.ts`.

Since `lookupHash` is an offer-level attribute, the filter targets `$.catalogs[*].beckn:offers[*]` directly:

```json
{
  "context": { "action": "discover", ... },
  "message": {
    "filters": {
      "type": "jsonpath",
      "expression": "$.catalogs[*].beckn:offers[*] ? (@.beckn:offerAttributes.gift.lookupHash == 'a1b2c3...sha256hex')"
    }
  }
}
```

If item-level conditions are also needed (e.g. networkId), use `exists()` to cross-reference:

```
$.catalogs[*].beckn:offers[*] ? (
  @.beckn:offerAttributes.gift.lookupHash == '<hash>'
  && exists($.catalogs[*] ? (
    @.beckn:items[*].beckn:networkId[*] == 'p2p-interdiscom-trading-pilot-network'
  ))
)
```

**CDS filter patterns reference:**

| Pattern | Use case |
|---------|----------|
| `$.catalogs[*].beckn:offers[*] ? (@... )` | Offer-only conditions (price, deliveryWindow, gift.lookupHash) |
| `$.catalogs[*] ? (@.beckn:items[*]... && @.beckn:offers[*]...)` | Mixed item + offer conditions in a single expression |
| `$.catalogs[*].beckn:offers[*] ? (@... && exists($.catalogs[*] ? (@.beckn:items[*]...)))` | Offer-level filter with item-level cross-reference |

This extends `buildDiscoverRequest` with an optional `lookupHash` parameter. When provided, it builds an offer-level filter with the hash as the primary condition.

**Visibility:** Gift offers also appear in normal discover results (tagged as gifts, visible to all), but only the holder of the claimSecret can proceed past on_select.

### 5.3 Claim Secret in Beckn Messages

The claimSecret is passed inside `beckn:acceptedOffer.beckn:offerAttributes.gift` at every Beckn stage (select, init, confirm). This places it in the same schema location as the `claimVerifier` it proves knowledge of:

```json
{
  "context": { "action": "select", ... },
  "message": {
    "order": {
      "beckn:orderItems": [{
        "beckn:orderedItem": "item-id",
        "beckn:acceptedOffer": {
          "@type": "beckn:Offer",
          "beckn:id": "offer-id",
          "beckn:offerAttributes": {
            "@type": "EnergyTradeOffer",
            "gift": {
              "claimSecret": "Ab3xK9mP"
            }
          }
        },
        "beckn:quantity": { "unitQuantity": 10, "unitText": "kWh" }
      }]
    }
  }
}
```

BPP extracts the secret from `orderItems[0].beckn:acceptedOffer.beckn:offerAttributes.gift.claimSecret` and validates at each stage:
1. `SHA256(claimSecret) === offer.claimVerifier` (stored in DB)
2. `offer.giftStatus === 'UNCLAIMED'`
3. `offer.expiresAt > now`

**Failure response** (Beckn NACK):

```json
{
  "context": { "action": "on_select", ... },
  "error": {
    "code": "GIFT_CLAIM_FAILED",
    "message": "Invalid claim secret or gift no longer available"
  }
}
```

---

## 6. Data Model

### Offers Collection — Extended Fields

```typescript
// Additional fields on offer documents when isGift=true
{
  // ... existing offer fields (beckn:id, beckn:price, beckn:offerAttributes, ...)

  isGift: boolean;                    // true for gift offers
  giftStatus: 'UNCLAIMED' | 'CLAIMED' | 'REVOKED' | 'EXPIRED';
  lookupHash: string;                 // SHA256(recipientPhone), indexed
  claimVerifier: string;              // SHA256(claimSecret)
  claimSecret: string;                // 8-char alphanumeric (stored for gifter view/resend)
  recipientPhone: string;             // E.164, stored for SMS resend
  expiresAt: Date;                    // default: creation + 7 days
  claimedAt?: Date;                   // set during on_confirm after successful claim validation
  claimedBy?: string;                 // beckn:buyer.beckn:id from the confirm message (recipient's DID)
}
```

**Indexes:**

```
{ lookupHash: 1, giftStatus: 1 }     // discovery queries
{ isGift: 1, userId: 1 }             // gifter's published items
```

---

## 7. Phone Number Validation

API accepts only 10-digit Indian mobile numbers. The `+91` prefix is added internally before hashing.

```typescript
const PHONE_REGEX = /^[6-9]\d{9}$/;

function validatePhone(phone: string): void {
  if (!PHONE_REGEX.test(phone)) {
    throw new Error('recipientPhone must be a 10-digit Indian mobile number (e.g. 9876543210)');
  }
}

function phoneToE164(phone: string): string {
  return '+91' + phone;  // 9876543210 → +919876543210
}

// Hashing always uses E.164
function computeLookupHash(phone: string): string {
  validatePhone(phone);
  return SHA256(phoneToE164(phone));  // SHA256('+919876543210')
}
```

**Both sides must hash identically:** The BAP computing the recipient's lookupHash must also prepend `+91` to the user's 10-digit phone before hashing. This is the canonical format for the network.

---

## 8. BPP Webhook Changes

### on_select — Gift Claim Validation

When the selected offer has `isGift: true`:

1. Extract `claimSecret` from the incoming message
2. Compute `SHA256(claimSecret)` and compare to `offer.claimVerifier`
3. Check `offer.giftStatus === 'UNCLAIMED'`
4. Check `offer.expiresAt > now`
5. If any check fails → return Beckn NACK with `GIFT_CLAIM_FAILED`
6. If all pass → proceed with normal on_select (build quote, return response)

### on_init — Re-validate

Same checks as on_select. Ensures no race condition between select and init.

### on_confirm — Finalize Claim

1. Re-validate claimSecret
2. Update `offer.giftStatus = 'CLAIMED'`, `claimedAt = now`, `claimedBy = buyerId`
3. Create standard order (as with any trade)
4. Log claim: `console.log('[GIFT] Gift ${offerId} claimed by ${buyerId}')`
5. Return standard on_confirm response

---

## 9. Expiry Handling

**Passive only** — no background poller.

- **During discovery:** CDS or BPP filters out offers where `expiresAt < now`
- **During claim:** BPP checks `expiresAt > now` at on_select/on_init/on_confirm
- **On gifter's dashboard:** UI shows "Expired" badge for offers past expiresAt

No active cleanup job. Expired offers remain in DB and CDS until natural catalog refresh.

---

## 10. Notification Flow

**MVP: console.log only.** SMS/email integration is a future enhancement.

### At gift creation

```typescript
console.log(`[GIFT] Created gift for ${recipientPhone}, claimSecret: ${claimSecret}, lookupHash: ${lookupHash}, expiresAt: ${expiresAt}`);
```

### At claim (on_confirm)

```typescript
console.log(`[GIFT] Gift ${offerId} claimed by ${buyerId}. Quantity: ${quantity} kWh, transactionId: ${transactionId}`);
```

### Future: SMS/email
- SMS to recipient with claimSecret at creation
- Notification to gifter at claim
- Resend SMS endpoint (`POST /api/publish/:offerId/resend-sms`)

---

## 11. Security Considerations

| Concern | Mitigation |
|---------|-----------|
| Phone reversal from lookupHash | SHA256 is one-way; phone enumeration is impractical without knowing the target |
| Brute force claimSecret | 8-char alphanumeric = ~2.8T combinations. No rate limiting needed. |
| claimSecret stored in plaintext | Acceptable for MVP — gifter needs to view/resend. Could encrypt-at-rest in future. |
| Gift visible to non-recipients | Visible in discover but locked — claim fails without secret |
| Replay attacks | claimSecret validated at every Beckn stage; status checked (UNCLAIMED only) |
| Race conditions | on_confirm atomically sets CLAIMED; concurrent claims fail |

---

## 12. Error Codes

| Code | When | Message |
|------|------|---------|
| `GIFT_CLAIM_FAILED` | Invalid claimSecret | "Invalid claim secret or gift no longer available" |
| `GIFT_EXPIRED` | Gift past expiresAt | "This gift has expired" |
| `GIFT_REVOKED` | Gifter revoked | "This gift has been revoked by the sender" |
| `GIFT_ALREADY_CLAIMED` | Already claimed | "This gift has already been claimed" |
| `GIFT_RECIPIENT_REQUIRED` | isGift=true but no phone | "Recipient phone number is required for gift offers" |
| `INVALID_PHONE_FORMAT` | Not 10 digits or doesn't start with 6-9 | "recipientPhone must be a 10-digit Indian mobile number (e.g. 9876543210)" |

---

## 13. Implementation Checklist

### Phase 1: Gift Creation
- [ ] Extend publish Zod schema with `isGift`, `recipientPhone`
- [ ] Add phone validation utility (10-digit, starts with 6-9, `+91` prepended internally)
- [ ] Add SHA256 hashing utility
- [ ] Add claimSecret generation (8-char alphanumeric)
- [ ] Extend offer document with gift fields
- [ ] Add `gift` to `offerAttributes` in catalog builder
- [ ] Allow price=0 for gifts (publish Zod schema has `z.number().positive()` which rejects zero; change to `.nonnegative()` when `isGift: true`)
- [ ] Log gift creation details via `console.log` (SMS is future)
- [ ] Return standard publish response (claimSecret available via published items listing)
- [ ] Add DB indexes (lookupHash + giftStatus)

### Phase 2: Discovery
- [ ] Extend on_search/discover handler to filter by lookupHash
- [ ] Ensure gift offers appear in normal discover (with gift tag)
- [ ] Filter out expired gifts at query time

### Phase 3: Claim Validation
- [ ] Extend on_select to validate claimSecret for gift offers
- [ ] Extend on_init to re-validate
- [ ] Extend on_confirm to finalize claim (set CLAIMED, notify gifter)
- [ ] Add Beckn NACK responses for failed claims

### Phase 4: Gifter Management
- [ ] Tag gift offers in published items listing
- [ ] Add `PATCH /api/publish/:offerId` for revoke
- [ ] Add `POST /api/publish/:offerId/resend-sms`
- [ ] Show claimSecret and masked recipientPhone in gifter's view

### Phase 5: Tests
- [ ] Gift creation (publish with gift fields)
- [ ] Phone validation (valid 10-digit, rejects +91 prefix, rejects short/long numbers, rejects starting with 0-5)
- [ ] Hash computation
- [ ] Claim validation (valid secret, wrong secret, expired, revoked, already claimed)
- [ ] Full Beckn flow (select → init → confirm with gift)
- [ ] Revoke and resend-SMS endpoints
